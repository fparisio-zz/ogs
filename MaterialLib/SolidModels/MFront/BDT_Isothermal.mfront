@Parser Implicit;
@Behaviour BDT_Isothermal;
@Algorithm NewtonRaphson_NumericalJacobian;
@Theta 1.;

@MaterialProperty real young;
young.setGlossaryName("YoungModulus");
@MaterialProperty real nu;
nu.setGlossaryName("PoissonRatio");
@MaterialProperty thermalexpansion alpha;
alpha.setGlossaryName("ThermalExpansion");
@MaterialProperty real f_c;
@MaterialProperty real m_0;
@MaterialProperty real alpha_p;
@MaterialProperty real n_exp_T;
@MaterialProperty real q_h0;
@MaterialProperty real chi_h;
@MaterialProperty real alpha_d_c;
@MaterialProperty real alpha_d_t;
@MaterialProperty real h_d;
@MaterialProperty real Qact;
@MaterialProperty real A_creep;
@MaterialProperty real n_creep;
@MaterialProperty real El_1;
@MaterialProperty real El_2;
@MaterialProperty real El_3;
@MaterialProperty real at_1;
@MaterialProperty real at_2;
@MaterialProperty real at_3;
@MaterialProperty real T_Solid;

@StateVariable real pla_mult;
@StateVariable real a;
@StateVariable real dam;
@StateVariable real damc;
@StateVariable real Rv;
@StateVariable real damt;
@StateVariable real vp;
@StateVariable real q_h;
@StateVariable real eps_p_vol;

@LocalVariable stress lambda;
@LocalVariable stress mu;
@LocalVariable stress Fel;
@LocalVariable StressStensor s0;

@Parameter Tref;
Tref.setDefaultValue(293.15);

@InitLocalVariables {
  real y2;
  if ((T_Solid-273.15)<20.0){
  y2 = El_1 * power<2>(20.0) + El_2 * 20.0 + El_3;  
  }else{
  y2 = El_1 * power<2>(T_Solid-273.15) + El_2 * (T_Solid-273.15) + El_3;
  }
  lambda = computeLambda(young * y2, nu);
  mu = computeMu(young * y2, nu);
  StressStensor sigel(lambda * trace(eel + deto) * Stensor::Id() +
                      2 * mu * (eel + deto)); // StresssStensor in Tutorial
  const auto s_dev = deviator(sigel);
  // J2 = (s_dev|s_dev)/2.; //defines double contraction
  const stress seq = sigmaeq(s_dev);
  const stress I1 = trace(sigel);
  const auto aux = (seq + I1) / (3. * f_c);

  const auto aux_ex = (1. - 1. / n_exp_T);
  const auto aux_arg = 1 + pow(alpha_p * (T_Solid-273.15 - 10.), n_exp_T);

  Rv = max(at_1 * (T_Solid-273.15) + at_2 * I1 / 3. + at_3, 1.0e-4);
  auto Rpel = -(1. - q_h0) * pow((a + vp) / Rv, 2) +
              2. * (1. - q_h0) * (a + vp) / Rv + q_h0;
  if ((a + vp) > Rv)
    Rpel = 1.0;

  q_h = Rpel / (pow(aux_arg, aux_ex));

  Fel = power<2>((1. - q_h) * power<2>(aux) + seq / f_c) +
        (m_0 * aux - 1) * power<2>(q_h);
}

@ComputeStress {
  sig = (1 - dam) * (lambda * trace(eel) * Stensor::Id() + 2 * mu * eel);
}

@Integrator {
  Stensor nvp = Stensor(0.);
  Stensor s_dev = deviator(sig / (1 - dam));
  const stress seq = sigmaeq(s_dev);

  if (seq > 1.e-15) {
    nvp = 1.5 * s_dev / seq;
  }
  fvp -= dt * A_creep * exp(-Qact / 8.3144598 / (T_Solid)) * pow(seq, n_creep);

  if (Fel > 0) {
    const real pla_mult_ = pla_mult + theta * dpla_mult;
    Stensor nq = s_dev;
    Stensor np = 1.0 * Stensor::Id();
    const auto aux = (seq + trace(sig / (1 - dam))) / (3. * f_c);

    const auto aux_ex = (1. - 1. / n_exp_T);
    const auto aux_arg = 1 + pow(alpha_p * (T_Solid-273.15 - 10), n_exp_T);
    real a_;
    real dam_;
    real vp_;

    a_ = a + theta * da;
    dam_ = dam + theta * ddam;
    vp_ = vp + theta * dvp;
    Rv = max(at_1 * (T_Solid-273.15) + at_2 * trace(sig / (1 - dam)) / 3. + at_3, 1.0e-4);
    auto Rp_ = -(1. - q_h0) * pow((a_ + vp_) / Rv, 2) +
               2. * (1. - q_h0) * (a_ + vp_) / Rv + q_h0;
    if ((a_ + vp_) > Rv)
      Rp_ = 1.0;
    q_h = Rp_ / (pow(aux_arg, aux_ex));

    const auto yield = power<2>((1. - q_h) * power<2>(aux) + seq / f_c) +
                       (m_0 * aux - 1) * power<2>(q_h);

    const auto big_aux = power<2>(aux) * (1 - q_h) + seq / f_c;
    const auto dev_flow =
        power<2>(q_h) * m_0 / (2. * f_c * seq) +
        2. * ((1 - q_h) * aux / (f_c * seq) + 3. / (2. * f_c * seq)) * big_aux;
    const auto iso_flow = power<2>(q_h) * m_0 / (3. * f_c) +
                          4. * (1. - q_h) * aux / (3. * f_c) * big_aux;

    feel =
        deel - deto + dpla_mult * (nq * dev_flow + np * iso_flow) + dvp * nvp;
    fpla_mult = yield / young;
    fa = da - sqrt(2. / 3. * (dpla_mult * (nq * dev_flow + np * iso_flow)) |
                   (dpla_mult * (nq * dev_flow + np * iso_flow)));

    feps_p_vol = deps_p_vol - dpla_mult * iso_flow;

    real n_exp_dam;
    n_exp_dam = 1.0;
    if (trace(sig / (1 - dam))<0){
        //fdc = ddc - max(min(1 - exp(-(((a + vp)*pow((q_h) , n_exp_dam) ) / alpha_d_c)), 1.0), 0.0);
        //fdc = ddc - max(- exp(-(((a + vp)*pow((q_h) , n_exp_dam) ) / alpha_d_c))*((-pow((q_h) , n_exp_dam)*(da+dvp))/alpha_d_c-(-n_exp_dam*dq_h*pow((q_h) , n_exp_dam-1)*(a+vp))/alpha_d_c), 0.0);
        fdamc = ddamc - pow(pow((exp(-((a + vp ) / alpha_d_c))*(da+dvp)*pow((q_h) , n_exp_dam))/alpha_d_c, 2.0),0.5);
        //fdamc = ddamc - max((exp(-((a + vp ) / alpha_d_c))*(da+dvp)*pow((q_h) , n_exp_dam))/alpha_d_c, 0.0);        
        }
    else{
        fdamt = ddamt - max((exp(-((a ) / alpha_d_t))*(da))/alpha_d_t, 0.0);
        }
    //dam= max(min(1.-(1-damc)*(1-damt), 1.0), 0.0);
    fdam = ddam - max(min((-ddamc*(damt-1)-ddamt*(damc-1)), 1.0), 0.0);

    sig = (1 - dam) * sig;
  } else {
    feel = deel - deto + dvp * nvp;
  }
}

@TangentOperator {
  if ((smt == ELASTIC) || (smt == SECANTOPERATOR)) {
    computeElasticStiffness<N, Type>::exe(Dt, lambda, mu);
  } else if (smt == CONSISTENTTANGENTOPERATOR) {
    StiffnessTensor De;
    Stensor4 Je;
    computeElasticStiffness<N, Type>::exe(De, lambda, mu);
    getPartialJacobianInvert(Je);
    Dt = De * Je;
  } else {
    return false;
  }
}
